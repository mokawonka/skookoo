<div class="pt-3 pb-3 text-center">
  

  <button id="collectionDropdown" type="button" class="btn dropdown-toggle gray" data-bs-toggle="dropdown" aria-expanded="false">
    English collection
  </button>

  <ul class="dropdown-menu  dropdown-menu-start">
      <li><%= link_to 'English collection (' + @englishCount.to_s + ' books)', '#', value: 'en', class: "dropdown-item collection-choice" %></li>
      <li><%= link_to 'French collection (' + @frenchCount.to_s + ' books)', '#', value: 'fr', class: "dropdown-item collection-choice" %></li>
  </ul>


  <%= form_with url: "/epub/search", method: :get, class: "form-group has-search", :html=> {:id => 'epub-search', novalidate: true} do |form|%>
    <div class="fa fa-search form-control-feedback"></div>
    <%= form.text_field :query, required: true,  placeholder: "Search for available books", autocomplete: "off", spellcheck: false, id: "epub-search-input", class: "form-control ds-input" %>
  <% end %>


    <div class="carousel-container position-relative">

        <!-- Loading overlay / spinner -->
        <div id="carousel-loading" class="loading-overlay">
            <div class="spinner"></div>
            <p class="loading-text">Loading free ebooks...</p>
        </div>


        <div class="carousel-track" id="epub-carousel"></div>
            <button class="carousel-btn prev" id="prevBtn">←</button>
            <button class="carousel-btn next" id="nextBtn">→</button>
        </div>
    </div>


<script>
document.addEventListener('turbo:load', () => {

  const track = document.getElementById('epub-carousel');
  const searchForm = document.getElementById('epub-search');
  const searchInput = document.getElementById('epub-search-input');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');

    if (!track) return;  
    if (!searchForm || !prevBtn || !nextBtn) {
        console.warn("Carousel elements missing on this page");
        return;
    }

    const loadingOverlay = document.getElementById('carousel-loading');
    if (!loadingOverlay) return;


  let allBooks = [];
  let filteredBooks = [];
  let nextPageUrl = '/epubs/available?lang=en';
  let isLoading = false;
  let currentIndex = 0;
  let cardWidth = 0;           // will be calculated after render
  let hasRenderedFirstPage = false; 


  let isDragging = false;
  let startX = 0;
  let currentTranslate = 0;
  let prevTranslate = 0;
  let animationID = null;

  let currentLang = 'en';

  loadMoreBooks();

  $('.collection-choice').on('click', function(e) {
    e.preventDefault();

    currentLang = $(this).attr('value'); // en | fr
    nextPageUrl = `/epubs/available?lang=${currentLang}`;

    const label = $(this).text();
    $('#collectionDropdown').text(label);

    resetCarousel();
    loadMoreBooks();
  });

  searchForm.addEventListener('submit', (e) => {
    e.preventDefault();

    const query = searchInput.value.trim();

    if (!query) {
      nextPageUrl = `/epubs/available?lang=${currentLang}`;
      resetCarousel();
      loadMoreBooks();
      return;
    }

    nextPageUrl =
      `/epubs/search?query=${encodeURIComponent(query)}&lang=${currentLang}`;

    resetCarousel();
    loadMoreBooks();
  });

  function resetCarousel() {
    allBooks = [];
    filteredBooks = [];
    track.innerHTML = '';
    currentIndex = 0;
    cardWidth = 0;
    hasRenderedFirstPage = false;
    nextPageUrl = nextPageUrl; // keep current (search or default)
    updateCarousel();
  }



function setupDrag() {
  // Remove old listeners if any (important after re-render)
  track.removeEventListener('pointerdown', pointerDown);
  track.removeEventListener('pointermove', pointerMove);
  track.removeEventListener('pointerup', pointerUp);
  track.removeEventListener('pointercancel', pointerUp);
  track.removeEventListener('mouseleave', pointerUp);

  track.addEventListener('pointerdown', pointerDown);
  track.addEventListener('pointermove', pointerMove);
  track.addEventListener('pointerup', pointerUp);
  track.addEventListener('pointercancel', pointerUp);
  // Also handle mouse leave as safety
  track.addEventListener('mouseleave', pointerUp);
}

function pointerDown(e) {
  isDragging = true;
  startX = e.pageX || e.touches?.[0]?.pageX || 0;   // works for mouse & touch

  currentTranslate = prevTranslate;   // start from last snapped position

  // Optional: add grabbing cursor
  track.style.cursor = 'grabbing';

  // Prevent text selection & default behaviors
  e.preventDefault();
}

function pointerMove(e) {
  if (!isDragging) return;

  const currentPosition = e.pageX || e.touches?.[0]?.pageX || 0;
  const diff = currentPosition - startX;

  currentTranslate = prevTranslate + diff;

  // Apply live drag
  track.style.transition = 'none';           // smooth during drag
  track.style.transform = `translateX(${currentTranslate}px)`;

  // Optional: stop buttons from being clickable during drag
  e.preventDefault();
}

function pointerUp(e) {
  if (!isDragging) return;
  isDragging = false;

  track.style.cursor = 'grab';   // or remove if you didn't set it

  // Calculate which card we should snap to
  const movedBy = currentTranslate - prevTranslate;
  const cardStep = cardWidth;   // your existing cardWidth + gap

  // How many cards did we move?
  let cardsMoved = Math.round(movedBy / cardStep);

  // Update index
  currentIndex = currentIndex - cardsMoved;   // note: negative because translate is negative

  // Clamp index
  const maxIndex = Math.max(0, filteredBooks.length - visibleCardsCount());
  currentIndex = Math.max(0, Math.min(currentIndex, maxIndex));

  // Snap back
  track.style.transition = 'transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
  currentTranslate = -currentIndex * cardWidth;
  track.style.transform = `translateX(${currentTranslate}px)`;

  prevTranslate = currentTranslate;

  loadMoreIfAtEnd();
}

function loadMoreBooks() {
  if (!nextPageUrl || isLoading) return;

  isLoading = true;

  fetch(nextPageUrl)
    .then(res => res.json())
    .then(data => {
      const newBooks = data.books || [];

      allBooks.push(...newBooks);
      filteredBooks.push(...newBooks);

      // Append only the new cards to the DOM
      appendNewCards(newBooks);

      nextPageUrl = data.pagination.next_page_url;
      isLoading = false;

      if (!hasRenderedFirstPage && newBooks.length > 0) {
        calculateCardWidth();
        hasRenderedFirstPage = true;
      }

      setupDrag();
      loadingOverlay.classList.add('hidden');
      $(searchForm).show();
    })
    .catch(err => {
      console.error("Failed to load epubs", err);
      // Optional: show error message instead of spinner
      loadingOverlay.innerHTML = `
        <p style="color: #dc2626;">Failed to load books</p>
        <button onclick="location.reload()">Retry</button>
      `;
    });
}

function appendNewCards(books) {
  books.forEach(book => {
    const card = document.createElement('div');
    card.className = 'epub-card';
    card.dataset.id = book.id;

    card.innerHTML = `
      <img src="${book.cover_url && book.cover_url.trim() !== '' 
          ? book.cover_url : "<%= asset_path('default_epub_cover.png') %>"}" 
           alt="${book.title}" loading="lazy">
           `;
      if(currentLang == "fr"){
        card.innerHTML +=       `
        <p class="text-center card-title">${book.title}</p>
        <h5 class="text-center">${book.authors}</h5>
      `;}


    card.addEventListener('click', () => {
      var actionurl = `/epubs/${book.id}/createfromdb`;
      $.post(actionurl, {
        authenticity_token: "<%= form_authenticity_token %>"
      })
      .done(() => {
        window.location.href = "<%= documents_path %>";
      })
      .fail((jqXHR, textStatus) => {
        alert("Error creating document: " + textStatus);
      });
    });

    track.appendChild(card);
  });
}

// Calculate card width only once (after first render)
function calculateCardWidth() {
  if (track.children.length === 0) return;
  const firstCard = track.children[0];
  const gap = parseFloat(window.getComputedStyle(track).gap) || 24;
  cardWidth = firstCard.offsetWidth + gap;
}


function atEndOfCarousel(buffer = 1) {
  const maxIndex = Math.max(0, filteredBooks.length - visibleCardsCount());
  return currentIndex >= maxIndex - buffer;
}

function loadMoreIfAtEnd() {
  if (atEndOfCarousel(1)) {
    loadMoreBooks();
  }
}

function maybeLoadMoreAtEnd() {
  const maxIndex = Math.max(0, filteredBooks.length - visibleCardsCount());

  // Load more when user reaches (or is very close to) the end
  if (currentIndex >= maxIndex - 1) {
    loadMoreBooks();
  }
}

  // 3. Navigation
  prevBtn.addEventListener('click', () => {
    if (currentIndex <= 0) return;
    currentIndex--;
    updateCarousel();
  });

  nextBtn.addEventListener('click', () => {
    const maxIndex = Math.max(0, filteredBooks.length - visibleCardsCount());
    if (currentIndex >= maxIndex) return;
    currentIndex++;
    updateCarousel();
    maybeLoadMoreAtEnd();
  });

  function updateCarousel() {
    track.style.transform = `translateX(-${currentIndex * cardWidth}px)`;
  }


  // Rough estimation — adjust breakpoints if needed
  function visibleCardsCount() {
    if (window.innerWidth < 768) return 1;
    if (window.innerWidth < 992) return 2;
    if (window.innerWidth < 1200) return 3;
    return 4; // or 5 — tune to your design
  }

});

</script>